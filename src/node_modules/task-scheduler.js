const scheduler = require('node-schedule');
const uuidv5 = require('uuid/v5');
const uuidv4 = require('uuid/v4');

// own
const logger = require('logger.js')("Task Scheduler Module");
const prettyPrint = require('pretty-print');


const ARGS = 0;
const TIME = 1;
const RECUR = 2;

// regex
const inRegex = /^[iI][nN]\s/;
const atRegex = /^[aA][tT]\s|^[@]\s/;

// any amount of digits, duration does not care
const inDigitRegex = "\\s\\d+";

// duration regex object
const durationRegexObj = {
  second: "\\ssec(ond)?(s)?",
  minute: "\\smin(ute)?(s)?",
  hour:   "\\sh(ou)?r(s)?",
  day:    "\\sday(s)?",
  week:   "\\sw(ee)?k(s)?",
};

// scheduler class that handles both the scheduling
// and persist storing of the schedules
class Scheduler {
  constructor(directory, taskHandler) {
    this.storage = require('node-persist');
    this.scheduler = require('node-schedule');
    this.directory = directory;
    this.taskHandler = taskHandler;
  }

  async init(client) {
    this.client = client;
    await this.storage.init({
      dir: this.directory,
    });
    logger.info(`Number of current task ${await this.storage.length()}`);
    const currentDT = new Date();
    await this.storage.forEach(async (data) => {
      const scheduledDT = new Date(data.value.scheduled);
      if (scheduledDT < currentDT) {
        logger.info(`Task ${data.key} has already expired on ${scheduledDT}. It will now be triggered immedately (${currentDT})`);
        await this.taskProcessor(this.client, data.key, data.value);
      } else {
        this.queue(data.key, data.value);
      }
    });
    logger.info(`Number of tasks after cleanup ${await this.storage.length()}`);
  }

  async add(channel, owner, type, args) {
    const cmdString = args.join(' ').split(',').map(arg => arg.trim());
    const scheduled = cmdString[TIME]; 
    const issueDT = new Date();

    let remindDT;
    if (inRegex.test(scheduled)) {
      remindDT = inDurationDatetime(scheduled);
    } 

    if (atRegex.test(scheduled)) {
    }

    if(!remindDT) {
      return null;
    }

    const uuiqID = uuidv5(args.join(' '), uuidv4());
    const task = {
      channel: channel,
      owner: owner,
      type: type,
      args: cmdString[ARGS],
      issued: issueDT,
      scheduled: remindDT,
      recur: cmdString[RECUR],
    };

    await this.storage.setItem(uuiqID, task);
    this.queue(uuiqID, task);
    return task;
  }

  async remove(key) {
    const data = await this.storage.getItem(key);
    logger.debug(`Removing item ${key} with data "${data.args}"...`);
    await this.storage.removeItem(key);
    logger.info(`Successfully removed item ${key}`);
  }

  async clear() {
    logger.debug(`Clearing all items...`);
    await this.storage.clear();
    logger.info(`Successfully cleared all items.`);
  }

  async getList() {
    const list = [];
    let i = 0;
    await this.storage.forEach(async (data) => {
      list.push({
        index: (i + 1).toString(),
        owner: data.value.owner,
        message: data.value.args,
        scheduled: data.value.scheduled, 
      });
      i++;
    });
    
    const header = {
      index: "#",
      scheduled: "Scheduled Time",
      owner: "Owner",
      message: "Message",
    }
    return prettyPrint.formatTable(header, list);
  }

  async taskProcessor(client, taskid, task) {
    this.taskHandler(client, task); 
    await this.remove(taskid); 
  }

  queue(taskid, task) {
    const scheduledDate = new Date(task.scheduled);
    this.scheduler.scheduleJob(scheduledDate, () => {
      this.taskProcessor(this.client, taskid, task); 
    });
  }
};

// this denotes a delay in the reminder system
// e.g. *in* 5 hours.
function inDurationDatetime(timeArgs) {
  const remindDate = new Date();
  // time regex object
  const duration = getDurationObj(durationRegexObj, timeArgs);
  remindDate.setSeconds(remindDate.getSeconds() + duration.second);
  remindDate.setMinutes(remindDate.getMinutes() + duration.minute);
  remindDate.setHours(remindDate.getHours() + duration.hour);
  remindDate.setDate(remindDate.getDate() + duration.day);
  remindDate.setDate(remindDate.getDate() + duration.week * 7);
  return remindDate;
}

function getDurationObj(regexObj, args) {
  
    // returns object of the duration result of each time unit.
  // if not found, that time unit will be 0 instead.
  return Object.keys(regexObj)
    .reduce((result, value) => {
      const curExp = new RegExp(inDigitRegex + regexObj[value]);
      const match = args.match(curExp);
      result[value] = match
        ? parseInt(match[0])
        : 0;
      return result;
    }, {});
}

// this denotes a specific datetime for the reminder
// e.g. *at* :3ndex: 2, input: 'in 1 hr' ]
//
function atSpecificDatetime(args) {

}

module.exports = Scheduler;
