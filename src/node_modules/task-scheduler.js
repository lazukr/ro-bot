const scheduler = require('node-schedule');
const uuidv5 = require('uuid/v5');
const uuidv4 = require('uuid/v4');
const moment = require('moment-timezone');

// own
const logger = require('logger.js')("Task Scheduler Module");
const pp = require('pretty-print');
const dt = require('data-tables');
const nvro = require('nova-market-commons');
const taskFactory = require('task-factory');
const objPrint = require('object-printer');

moment.locale('en', {
  calendar: {
    lastDay : '[Yesterday at] LT',
    sameDay : '[Today at] LT',
    nextDay : '[Tomorrow at] LT',
    lastWeek : '[on last] dddd [at] LT',
    nextWeek : '[on] dddd [at] LT',
    sameElse : '[on] llll'
  }
});

const USERDB = 'src/userdb';

// scheduler class that handles both the scheduling
// and persist storing of the schedules
class Scheduler {
  constructor(directory) {
    this.storage = require('node-persist');
    this.userdb = this.storage.create();
    this.scheduler = require('node-schedule');
    this.factory = new taskFactory.TaskFactory();
    this.directory = directory;
    this.scheduledJobs = {};
  }

  get header() {
    return {
      index: "#",
      scheduled: "Scheduled Time",
      owner: "Owner",
      message: "Message",
    };
  }

  get autoMarketHeader() {
    return {
      index: "#",
//      scheduled: "Interval (mins)",
      owner: "Owner",
      itemID: "ItemID",
      filters: "Filtering on",
    };
  }

  getScheduledJobs(owner = null) {
    const ids = Object.keys(this.scheduledJobs);
    logger.info(`Getting items in scheduler...`);  
    const allSchedules = ids.map(id => this.scheduledJobs[id]).filter(job => owner ? job.ownerid === owner : true);
    //console.log(allSchedules); 
  }

  async init(client) {
    this.client = client;
    await this.storage.init({
      dir: this.directory,
    });

    await this.userdb.init({
      dir: USERDB, 
    });
    await this._initialTaskHandler();
  }

  async _initialTaskHandler() {
    logger.info(`Number of current task ${await this.storage.length()}`);
    const currentDT = new Date();
    await this.storage.forEach(async (data) => {
      logger.debug(`key: ${data.key}.`);
      logger.debug(`task:`);
      objPrint(data.value, 2);
      
      if (data.key == taskFactory.INTERVAL) {
        logger.debug(`interval task`);
        return;
      }
      const task = this.factory.getTask(data.value);
      if (task.type == taskFactory.MSG &&
          task.isExpired(currentDT)) {
        logger.info(`Task ${data.key} has already expired on ${task.scheduled}. It will now trigger immediately at ${currentDT}`);
        await this.processTask(data.key, task);
        return;
      } 
      await this.queue(data.key, task);
    });    
    logger.info(`Number of task after startup ${await this.storage.length()}`);
  }

  async add(props) {
    const task = this.factory.makeTask(props); 
    if (!task) {
      return null;
    }
    await this.storage.setItem(task.uuid, task.job);
    await this.queue(task.uuid, task.job);
    return task.job; 
  }

  async remove(identifier, index) {
    const list = await this._getMessageKeysOfType(identifier);
    if (list.length < index) {
      return "Index selected is larger than the number of items in list.";
    }
    const removeStatus = await this._remove(list[index - 1]);
    logger.info(removeStatus);
    if (!removeStatus.existed) {
      return "Item was not found.";
    }
    return "Item successfully removed.";
  }

  cancelAllJobs() {
    logger.info(`Cancelling all jobs...`);
    const scheduledJobs = Object.keys(this.scheduledJobs);
    scheduledJobs.forEach(key => {
      this._cancelJob(key);
    });    
  }

  _cancelJob(key) {
    if (key in this.scheduledJobs &&
      this.scheduledJobs[key]) {
      this.scheduledJobs[key].cancel();
      delete this.scheduledJobs[key];
      logger.info(`Scheduled jobs: ${JSON.stringify(this.scheduledJobs)}`);
    }
  }

  async _remove(key) {
    this._cancelJob(key);
    const data = await this.storage.getItem(key);
    logger.debug(`Removing item ${key} with data "${data.args}"...`);
    const removeStatus = await this.storage.removeItem(key);
    return removeStatus;
  }

  async clear(identifier) {
    logger.debug(`Clearing all ${identifier} items...`);
    await this.storage.forEach(async (task) => {
      if (task.key.includes(identifier)) {
        await this._remove(task.key);
      }
    });
    logger.info(`Successfully cleared all ${identifier} items.`);
  }

  async _getMessageKeysOfType(identifier) {
    const list = await this.storage.keys();
    return list.filter(key => {
      return key.includes(identifier);
    }).sort((a, b) => a > b);
  }

  async _getMessageOfType(identifier) {
    const list = [];
    await this.storage.forEach(async (task) => {
      if (task.key.includes(identifier)) {
        list.push(task);
      }
    });

    return list
      .sort((a, b) => a.key > b.key)
      .map(task => task.value);
  }

  async getMessageList(page) {
    const msgList = await this._getMessageOfType(taskFactory.MSG);
    const list = await Promise.all(msgList.map(async (data, i) => {
      const parseDate = Date.parse(data.scheduled);
      const localized = await this.timeLocalize(data.ownerid, data.scheduled);
      const scheduled = isNaN(data.scheduled) &&
        !isNaN(parseDate) ? 
        await this.timeLocalize(data.ownerid, data.scheduled) :
        data.scheduled;
      return {
        index: (i + 1).toString(),
        owner: data.owner,
        message: data.args,
        scheduled: scheduled, 
      };
    }));
  
    const messageTable = {
      name: "Reminders",
      table: new dt.DataTable(this.header, list),
    };
    const prettyTable = new pp.PrettyTableFactory(messageTable); 
    return prettyTable.getPage(page);
  }

  async _getAutoMarketList(ownerid = null) {
    const amList = await this._getMessageOfType(taskFactory.AUTOMARKET);
    const list = amList.filter(i => ownerid ? i.ownerid === ownerid : true);
    console.log(list);
    
    if (list.length === 0) {
      return;
    }
    
    const amResult = await Promise.all(list.map(async data => {
      const result = await nvro.getLiveMarketData(data.itemID);  
      if (result.error != nvro.ERROR.NONE) {
        return;
      }
      return {...result, filters: data.filters}; 
    }));

    const filteredResults = amResult
      .filter(x => x != null)
      .map((data, i) => {
        console.log(data);
        data.table.intToStrCols(nvro.HEADERS.QTY);
        data.table.intToStrCols(nvro.HEADERS.PRICE);
        data.table.intToStrCols(nvro.HEADERS.REFINE);
        const prettyTable = new pp.PrettyTableFactory(data);
        return prettyTable.hasResults(data.filters) ?  
          prettyTable.getPage(1, data.filters, true) :
          null;
      });
    const replyResults = filteredResults
      .filter(x => x != null);
    console.log(replyResults);
    return replyResults;
  }

  async getAutoMarketList(page) {
    const automarketList = await this._getMessageOfType(taskFactory.AUTOMARKET);
    const list = await Promise.all(automarketList.map(async (data, i) => {
      console.log(data);

      const filterString = data.filters[nvro.HEADERS.ADDPROPS];
      if (data.filters[nvro.HEADERS.PRICE]) {
        const price = `${data.filters[nvro.HEADERS.PRICE].toLocaleString()}z`;
        filterString.unshift(price);
      }

      const refine = data.filters[nvro.HEADERS.REFINE];
      if (refine) {
        filterString.unshift(refine);
      }
      const interval = await this.getCronInterval();
      const scheduled = `Every ${interval} minute${interval == 1 ? "" : "s"}`;
      
      const name = data.itemID === data.name ? data.itemID.toString() : `${data.itemID} - ${data.name}`;
      
      
      return {
        index: (i + 1).toString(),
        owner: data.owner,
        itemID: name,
        scheduled: scheduled,
        filters: filterString.join(', '),
      };
    }));
    const automarketTable = {
      name: "Auto Market",
      table: new dt.DataTable(this.autoMarketHeader, list),
    };
    
    const prettyTable = new pp.PrettyTableFactory(automarketTable);
    return prettyTable.getPage(page);
  }

  async setCronInterval(interval) {
    this.storage.setItem(taskFactory.INTERVAL, interval);
    this.storage.forEach(async (am) => {
      if (am.key.includes(taskFactory.AUTOMARKET)) {
        am.value.scheduled = `30 */${interval} * * * *`;
        await this.storage.setItem(am.key, am.value); 
        this._cancelJob(am.key);
        
        const task = this.factory.makeTask(am.value);
        await this.queue(am.key, task);
        logger.info(`${am.key} task of ${JSON.stringify(am.value)} rescheduled.`);
      }
    });
  }

  async getCronInterval() {
    return await this.storage.getItem(taskFactory.INTERVAL);
  }

  async processTask(jobName, taskid, task) {
    logger.info(`Processing task...\n${taskid}`); 
    const channel = this.client.channels.get(task.channel);
    await task.process(channel);
    
    if (task.type == taskFactory.MSG) {
      await this._remove(taskid);
      this._cancelJob(taskid);
    }
  }

  async queue(taskid, task) {
    logger.info(`Queuing task: ${taskid}`);
    const jobName = `${taskid}@${new Date()}`;
    const job = this.scheduler.scheduleJob(jobName, task.scheduled, async function() {
      await this.processTask(jobName, taskid, task); 
    }.bind(this));
    this.scheduledJobs[taskid] = job;
    this.getScheduledJobs();
  }

  async timeLocalize(userid, scheduled) {
    const timezone = await this.userdb.getItem(userid);
    return moment(scheduled).tz(timezone).calendar();
  }
};

module.exports = Scheduler;
