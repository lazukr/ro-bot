const scheduler = require('node-schedule');
const uuidv5 = require('uuid/v5');
const uuidv4 = require('uuid/v4');
const moment = require('moment-timezone');

// own
const logger = require('logger.js')("Task Scheduler Module");
const pp = require('pretty-print');
const taskFactory = require('task-factory');

moment.locale('en', {
  calendar: {
    lastDay : '[Yesterday at] LT',
    sameDay : '[Today at] LT',
    nextDay : '[Tomorrow at] LT',
    lastWeek : '[on last] dddd [at] LT',
    nextWeek : '[on] dddd [at] LT',
    sameElse : '[on] llll'
  }
});

const USERDB = 'src/userdb';

// scheduler class that handles both the scheduling
// and persist storing of the schedules
class Scheduler {
  constructor(directory) {
    this.storage = require('node-persist');
    this.userdb = this.storage.create();
    this.scheduler = require('node-schedule');
    this.factory = new taskFactory.TaskFactory();
    this.directory = directory;
    this.scheduledJobs = {};
  }

  get header() {
    return {
      index: "#",
      scheduled: "Scheduled Time",
      owner: "Owner",
      message: "Message",
    };
  }

  get autoMarketHeader() {
    return {
      index: "#",
      scheduled: "Interval (mins)",
      owner: "Owner",
      itemID: "ItemID",
      price: "Price",
    };
  }

  async init(client) {
    this.client = client;
    await this.storage.init({
      dir: this.directory,
    });

    await this.userdb.init({
      dir: USERDB, 
    });
    await this._initialTaskHandler();
  }

  async _initialTaskHandler() {
    logger.info(`Number of current task ${await this.storage.length()}`);
    const currentDT = new Date();
    await this.storage.forEach(async (data) => {
      if (data.key == taskFactory.INTERVAL) {
        return;
      }
      const task = this.factory.getTask(data.value);
      console.log(data.key);
      console.log(task);
      if (task.type == taskFactory.MSG &&
          task.isExpired(currentDT)) {
        logger.info(`Task ${data.key} has already expired on ${task.scheduled}. It will now trigger immediately at ${currentDT}`);
        await this.processTask(data.key, task);
        return;
      } 
      this.queue(data.key, task);
    });    
    logger.info(`Number of task after startup ${await this.storage.length()}`);
  }

  async add(props) {
    const task = this.factory.makeTask(props); 
    if (!task) {
      return null;
    }
    await this.storage.setItem(task.uuid, task.job);
    this.queue(task.uuid, task.job);
    return task.job; 
  }

  async remove(identifier, index) {
    const list = await this._getMessageKeysOfType(identifier);
    if (list.length < index) {
      return "Index selected is larger than the number of items in list.";
    }
    const removeStatus = await this._remove(list[index - 1]);
    logger.info(removeStatus);
    if (!removeStatus.existed) {
      return "Item was not found.";
    }
    return "Item successfully removed.";
  }

  _cancelJob(key) {
    if (key in this.scheduledJobs) {
      this.scheduledJobs[key].cancel();
      this.scheduledJobs[key];
    }
  }

  async _remove(key) {
    this._cancelJob(key);
    const data = await this.storage.getItem(key);
    logger.debug(`Removing item ${key} with data "${data.args}"...`);
    const removeStatus = await this.storage.removeItem(key);
    return removeStatus;
  }

  async clear(identifier) {
    logger.debug(`Clearing all ${identifier} items...`);
    await this.storage.forEach(async (task) => {
      if (task.key.includes(identifier)) {
        await this._remove(task.key);
      }
    });
    logger.info(`Successfully cleared all ${identifier} items.`);
  }

  async _getMessageKeysOfType(identifier) {
    const list = await this.storage.keys();
    return list.filter(key => {
      return key.includes(identifier);
    });
  }

  async _getMessageOfType(identifier) {
    const list = [];
    await this.storage.forEach(async (task) => {
      if (task.key.includes(identifier)) {
        list.push(task.value);
      }
    });
    return list;
  }

  async getMessageList() {
    const msgList = await this._getMessageOfType(taskFactory.MSG);
    const list = await Promise.all(msgList.map(async (data, i) => {
      const scheduled = await this.timeLocalize(data.ownerid, data.scheduled);
      return {
        index: (i + 1).toString(),
        owner: data.owner,
        message: data.args,
        scheduled: scheduled, 
      };
    }));
   return pp.print(this.header, list).formatted;
  }

  async getAutoMarketList() {
    const automarketList = await this._getMessageOfType(taskFactory.AUTOMARKET);
    const list = await Promise.all(automarketList.map(async (data, i) => {
      const interval = await this.getCronInterval();
      const scheduled = `Every ${interval} minute${interval == 1 ? "" : "s"}`;
      return {
        index: (i + 1).toString(),
        owner: data.owner,
        itemID: data.args[0],
        price: data.args[1],
        scheduled: scheduled,
      };
    }));
    return pp.print(this.autoMarketHeader, list).formatted;
  }

  async setCronInterval(interval) {
    this.storage.setItem(taskFactory.INTERVAL, interval);
  }

  async getCronInterval() {
    return await this.storage.getItem(taskFactory.INTERVAL);
  }

  async processTask(taskid, task) {
    const channel = this.client.channels.get(task.channel);
    await task.process(channel);
    
    if (task.type == taskFactory.MSG) {
      await this._remove(taskid);
      this._cancelJob(taskid);
    }
  }

  queue(taskid, task) {
    logger.info(`Queuing task: ${taskid}`);
    const job = this.scheduler.scheduleJob(task.scheduled, () => {
      this.processTask(taskid, task); 
    });
    this.scheduledJobs[taskid] = job;
  }

  async timeLocalize(userid, scheduled) {
    const timezone = await this.userdb.getItem(userid);
    return moment(scheduled).tz(timezone).calendar();
  }
};

module.exports = Scheduler;
