const logger = require('logger.js')("nova-market module");
const rp = require('request-promise');
const cheerio = require('cheerio');

const marketLink = 'https://www.novaragnarok.com';
const abbrvObj = {
  "Additional Properties": "Add Props",
  "Refine": "Rfn",
};
const QTY = 'Qty';
const ITEM = 'Item';
const PRICE = 'Price';

async function getLiveMarketData(itemId) {
  // grab market info from page itself
  const $ = await getMarket(marketLink, itemId);
  const result = getMarketTable($);
  
  // no result case
  if (!result) {
    return {
      "name": getItemNameFromId($),
    };
  }

  // if there is a quantity column,
  // get rid of the 'ea.' and convert them into int
  if (result.table[0][QTY]) {
    result.table = getIntsInCol(result.table, QTY); 
  }  
 
  // cleans up price column of any non integer
  // characters and converts it into integers 
  result.table = getIntsInCol(result.table, PRICE);
  sortAscending(result.table, PRICE);

  return {
    "name": getItemNameFromId($),
    "header": result.header,
    "table": result.table,
  };
}

// uses request-promise to get the actual webpage
async function getMarket(url, id) {
  const options = {
    method: 'GET',
    uri:    url,
    qs: {
      "module": "vending",
      "action": "item",
      "id": `${id}`,
    },
    resolveWithFullResponse: true,
    transform: function(body) {
      return cheerio.load(body);
    },
  };

  return rp(options)
    .then($ => {
      return $;
    })
    .catch(error => {
      logger.error(`An error has occurred on request. ${error}`);
    });
};

// gets the full table of the market
function getMarketTable($) {
  // get table, headers and all rows
  const table = $('#itemtable').get(0);
  
  // if table doesn't exist, then there are no results
  if (!table) {
    return null;
  }
  const th = selectRowContent($, table, 'th');
  const tr = selectRowContent($, table, 'td');
  
  // abbreviate the headers
  const headers = th.map((el, index) => {
   return abbrvObj[el] ? abbrvObj[el] : el;
  });

  // selectRowContent has everything in one array
  // remap it so that you get a 2d array
  // so each row corresponds to each entry of the table
  const rows = arrayTo2D(tr, headers.length);

  // turn each row of content into dictionaries 
  return {
    "header": getHeadersAsDictRow(headers),
    "table": convertArrayRowsToDictRows(headers, rows),
  };
}

// grabs all the content of relevant type
function selectRowContent($, table, type) {
  const elements = [];
  $(table).find(`tr ${type}`).each((i, elem) => {
    let element = $(elem).text().trim();
    if (element == "") {
      element = $(elem).find('img').attr('src').match(/\d{3,}/)[0];
    }
    elements.push(element);
  });
  return elements;
}

// gets the name of the item from the itemID
function getItemNameFromId($) {
  const header = $('h2').get(0);
  return $(header).find('a').text().trim();
}

// remaps an array into a 2D array by splitting 
// on every N (splitLength) entries.
function arrayTo2D(array, splitLength) {
  return array.reduce((result, value, index, array) => {
    if (index % splitLength === 0) {
      result.push(array.slice(index, index + splitLength));
    }
    return result;
  }, []);
}

// converts each array representation of a row into
// a dictionary representation
function convertArrayRowsToDictRows(headers, rows) {
  return rows.map(rowContents => {
    return rowContents.reduce((result, value, index) => {
      result[headers[index]] = value;
      return result;
    }, {});
  });
}

// get headers as a dictionary Row
function getHeadersAsDictRow(headers) {
  return headers.reduce((result, value, index) => {
    result[headers[index]] = headers[index];
    return result;
  }, {});
}

// removes unnecessary characters from the integer
// columns and convert them into integers
function getIntsInCol(array, col) {
  return array.map(row => {
    row[col] = parseInt(row[col].replace(/,/g, ''));
    return row;
  });
}

// sorting smallest to largest
function sortAscending(array, sortBy) {
  array.sort((a, b) => {
    return a[sortBy] - b[sortBy];
  });
}

exports.getLiveMarketData = getLiveMarketData;
