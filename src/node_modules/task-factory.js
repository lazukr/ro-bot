const uuidv5 = require('uuid/v5');
const uuidv4 = require('uuid/v4');
const market = require('nova-market-commons');
const pp = require('pretty-print');
const mvploc = require('mvp-loc.json');
 

const MSG = "message";
const AUTOMARKET = "automarket";
const INTERVAL = "interval";
const REMOVE = "remove";

const HIGHLIGHT = 'JSON';
// message cmd parse
const ARGS = 0;
const TIME = 1;
const RECUR = 2;

// automarket cmd parse
const ID = 0;
const PRICE = 1;

// regex
const inRegex = /in(?!.*in).*/;

// any amount of digits, duration does not care
const inDigitRegex = "\\s\\d+";

// duration regex object
const durationRegexObj = {
  second: "\\ssec(ond)?(s)?",
  minute: "\\smin(ute)?(s)?",
  hour:   "\\sh(ou)?r(s)?",
  day:    "\\sday(s)?",
  week:   "\\sw(ee)?k(s)?",
};

class Task {
  constructor(props) {
    this.channel = props.channel;
    this.ownerid = props.ownerid;
    this.owner = props.owner;
    this.type = props.type;
    this.args = props.args;
    this.issued = props.issued;
    this.scheduled = props.scheduled;
  }
  
  process() {

  }
}

class MessageTask extends Task {
  constructor(props) {
    super(props);
    this.scheduled = new Date(this.scheduled);
  }
  
  get mvploc() {
    return require('mvp-loc.json');
  }

  get naviRegex() {
    return /^[0-9]{1,3}$/;
  }

  async process(channel) {
    const argsArray = this.args.split(' ');
    console.log(argsArray);
    if (argsArray.length == 3 &&
        this.mvploc[argsArray[0]] &&
        this.naviRegex.test(argsArray[1]) &&
        this.naviRegex.test(argsArray[2]))
    {
      channel.send(`<@${this.ownerid}>! Bear has meesage for you. \`\`\`@navi ${this.mvploc[argsArray[0]]} ${argsArray[1]}/${argsArray[2]}\`\`\``);
      return;
    }

    channel.send(`<@${this.ownerid}>! Bear has message for you. \`\`\`${this.args}\`\`\``);
  }

  isExpired(current) {
    if (this.scheduled < current) {
      return true;
    }
    return false;
  }
}

class AutoMarketTask extends Task {
  constructor(props) {
    super(props);
  }

  async process(channel) {
    const itemID = this.args[0];
    let price = parseFloat(this.args[1]); 
     
    if (this.args[1].includes("k")) {
      price *= 1000;   
    } else if (this.args[1].includes("m")) {
      price *= 1000000;
    } else {
      price *= 1000000000;
    }
    
    const liveMarket = await market.getLiveMarketData(itemID);
    
    if (!liveMarket) {
      console.log("No results");
    }   
    
    liveMarket.table = liveMarket.table.filter(row => {
      return row.Price <= price;
    }); 

    if (liveMarket.table.length == 0) {
      console.log("No matching results");
    }
    
    if (liveMarket.header[pp.QTY]) {
      liveMarket.table = pp.getStringIntsInCol(liveMarket.table, pp.QTY);
    }

    liveMarket.table = pp.getStringIntsInCol(liveMarket.table, pp.PRICE);

    const prettyTable = pp.print(liveMarket.header, liveMarket.table, true);
    channel.send(`<@${this.ownerid}>! Bear has found item within price range.`);

    if (prettyTable.firstMsg) {
      channel.send(`\`\`\`${liveMarket.name}\n\n\n${prettyTable.firstMsg.join("\n")}\`\`\``);
    }   
       
    prettyTable.formatted.forEach(msg => {
      channel.send(`${HIGHLIGHT}\n${msg.join("\n")}\`\`\``);
    });
  }
}

class TaskFactory {
  getTask(props) {
    if (props.type == MSG) {
      return new MessageTask(props);
    } else if (props.type == AUTOMARKET) {
      return new AutoMarketTask(props);
    }
  }
  
  makeTask(props) {
    const uuid = uuidv5(props.args.join(' '), uuidv4());
    if (props.type == MSG) {
      const msgProps = this._processMessageArgs(props);    
      if (!msgProps) {
        return null;
      } 
      return {
        uuid: `${MSG}+${uuid}`,
        job: new MessageTask(msgProps),
      };
    } else if (props.type == AUTOMARKET) {
      const automarketProps = this._processAutoMarketArgs(props);
      return {
        uuid: `${AUTOMARKET}+${uuid}`,
        job: new AutoMarketTask(automarketProps),
      }; 
    } else {
      return null;
    }
  }

  _processMessageArgs(props) {
    const cmd = props.args.join(' ');
    const issued = new Date();
    const inMatches = cmd.match(inRegex)[0];
    if (!inMatches) {
      return null;
    }
    const remind = inDurationDatetime(inMatches);
    let msg = cmd.replace(inMatches, "").trim();
    if (msg[msg.length - 1] == ",") {
      msg = msg.substr(0, msg.length - 2);
    }

    if (!remind) {
      return null;
    }

    return {
      channel: props.channel,
      owner: props.owner,
      ownerid: props.ownerid,
      type: props.type,
      args: msg,
      issued: issued,
      scheduled: remind,
    };
  }

  _processAutoMarketArgs(props) { 
    const issued = new Date();
    const scheduled = `0 */${props.interval} * * * *`;
    return {
      channel: props.channel,
      owner: props.owner,
      ownerid: props.ownerid,
      type: props.type,
      args: props.args,
      issued: issued,
      scheduled: scheduled,
    };  
  }
}

// this denotes a delay in the reminder system
// e.g. *in* 5 hours.
function inDurationDatetime(timeArgs) {
  const remindDate = new Date();
  // time regex object
  const duration = getDurationObj(durationRegexObj, timeArgs);
  console.log(duration); 
  const hasDur = !Object.values(duration).every(o => o === null);
  if (!hasDur) {
    return null;
  } 

  remindDate.setSeconds(remindDate.getSeconds() + duration.second);
  remindDate.setMinutes(remindDate.getMinutes() + duration.minute);
  remindDate.setHours(remindDate.getHours() + duration.hour);
  remindDate.setDate(remindDate.getDate() + duration.day);
  remindDate.setDate(remindDate.getDate() + duration.week * 7);
  return remindDate;
}

function getDurationObj(regexObj, args) {
  
    // returns object of the duration result of each time unit.
  // if not found, that time unit will be 0 instead.
  return Object.keys(regexObj)
    .reduce((result, value) => {
      const curExp = new RegExp(inDigitRegex + regexObj[value]);
      const match = args.match(curExp);
      result[value] = match
        ? parseInt(match[0])
        : null;
      return result;
    }, {});
}

// this denotes a specific datetime for the reminder
// e.g. *at* :3ndex: 2, input: 'in 1 hr' ]
//
function atSpecificDatetime(args) {

}

module.exports.TaskFactory = TaskFactory;
module.exports.MSG = MSG;
module.exports.AUTOMARKET = AUTOMARKET;
module.exports.INTERVAL = INTERVAL;
module.exports.REMOVE = REMOVE;
