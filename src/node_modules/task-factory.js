const uuidv5 = require('uuid/v5');
const uuidv4 = require('uuid/v4');
const nvro = require('nova-market-commons');
const pp = require('pretty-print');
const mvploc = require('mvp-loc.json');
const logger = require('logger')("Task Factory module: ");
const objPrint = require('object-printer');

const MSG = "message";
const AUTOMARKET = "automarket";
const INTERVAL = "interval";
const REMOVE = "remove";
const LIST = "list";
const CLEAR = "clear";

const TYPE = Object.freeze({
  MSG: "message",
  AUTOMARKET: "automarket",
});

const CMD = Object.freeze({
  REMOVE: "remove",
  LIST: "list",
  CLEAR: "clear",
  INTERVAL: "interval",
  ALL: "all",
});

const HIGHLIGHT = 'JSON';
// message cmd parse
const ARGS = 0;
const TIME = 1;
const RECUR = 2;

// automarket cmd parse
const ID = 0;
const PRICE = 1;

// regex
const inRegex = /in(?!.*\sin).*/;
const atRegex = /at(?!.*\sat).*/;
const everyRegex = /every(?!.*\severy).*/;

// any amount of digits, duration does not care
const inDigitRegex = "\\s\\d+";

// duration regex object
const durationRegexObj = {
  second: "\\ss(ecs|ec)?",
  minute: "\\sm(ins|in)?",
  hour:   "\\sh(rs|r)?",
  day:    "\\sd(ays|ay)?",
  week:   "\\sw(ks|k)?",
};

class Task {
  constructor(props) {
    this.channel = props.channel;
    this.ownerid = props.ownerid;
    this.owner = props.owner;
    this.type = props.type;
    this.args = props.args;
    this.issued = props.issued;
    this.scheduled = props.scheduled;
  }
  
  process() {

  }
}

class MessageTask extends Task {
  constructor(props) {
    super(props);
    const parseDate = Date.parse(this.scheduled);
    this.scheduled = isNaN(this.scheduled) && !isNaN(parseDate) ?
      this.scheduled :
      new Date(this.scheduled);
  }
  
  get mvploc() {
    return require('mvp-loc.json');
  }

  get naviRegex() {
    return /^[0-9]{1,3}$/;
  }

  async process(channel) {
    const argsArray = this.args.split(' ');
    console.log(argsArray);
    if (argsArray.length == 3 &&
        this.mvploc[argsArray[0]] &&
        this.naviRegex.test(argsArray[1]) &&
        this.naviRegex.test(argsArray[2]))
    {
      channel.send(`<@${this.ownerid}>! Bear has meesage for you. \`\`\`@navi ${this.mvploc[argsArray[0]]} ${argsArray[1]}/${argsArray[2]}\`\`\``);
      return;
    }

    channel.send(`<@${this.ownerid}>! Bear has message for you. \`\`\`${this.args}\`\`\``);
  }

  isExpired(current) {
    if (this.scheduled < current) {
      return true;
    }
    return false;
  }
}

class AutoMarketTask extends Task {
  constructor(props) {
    super(props);
    this.itemID = props.itemID;
    this.filters = props.filters;
    this.name = props.name;
    this.results = [];
  }

  async process(channel, feed = null) {
    logger.info(`Processing task in ch: ${channel}. Task:`);
    objPrint(this, 2);
    const itemID = this.itemID;
    const automarket = feed ? feed : await nvro.getLiveMarketData(itemID);
    
    if (automarket.error === nvro.ERROR.NO_LOGIN) {
      logger.info(`automarket failed to login`);
      channel.send(`Bear was unable to login.`);
      return;
    }

    if (automarket.error !== nvro.ERROR.NONE) {
      // previous had no results already
      if (this.results.length === 0) {
        return;
      }
      // previous had results, thus message
      logger.info(`automarket error: ${automarket.error}`);
      this.results = [];
      channel.send(`<@${this.ownerid}>! Bear has message for you.\n\`\`\`${pp.HIGHLIGHT}\n${automarket.id} - ${automarket.name}\n\nNo Results Found :(\n\`\`\``); 
      return;
    }   
    automarket.table.intToStrCols(nvro.HEADERS.QTY);
    automarket.table.intToStrCols(nvro.HEADERS.PRICE);
    automarket.table.intToStrCols(nvro.HEADERS.REFINE);
    const prettyTable = new pp.PrettyTableFactory(automarket);
    const page = prettyTable.getFilteredResults(this.filters);

    // pings if there is a change in results
    if (JSON.stringify(this.results) !== JSON.stringify(page)) {
      logger.info(`There were changes for ${this.name} with filters:`);
      objPrint(this.filters, 2);
      this.results = page;
      channel
        .send(`<@${this.ownerid}>! Bear has message for you.\n ${prettyTable.getPage(1, this.filters)}`)
        .catch(err => {
          channel.send(`<@${this.ownerid}>! There are automarket results, but an error was encountered: ${err.message}`);
        });
      return;
    }
    
    logger.info(`No changes in results for ${this.name} with filters:`);
    objPrint(this.filters, 2);
  }
}

class TaskFactory {
  getTask(props) {
    if (props.type == MSG) {
      return new MessageTask(props);
    } else if (props.type == AUTOMARKET) {
      return new AutoMarketTask(props);
    }
  }
  
  makeTask(props) {
    const uuid = uuidv5(props.args.join(' '), uuidv4());
    if (props.type == MSG) {
      const msgProps = this._processMessageArgs(props);    
      if (!msgProps) {
        return null;
      } 
      return {
        uuid: `${MSG}+${uuid}`,
        job: new MessageTask(msgProps),
      };
    } else if (props.type == AUTOMARKET) {
      const automarketProps = this._processAutoMarketArgs(props);
      return {
        uuid: `${AUTOMARKET}+${uuid}`,
        job: new AutoMarketTask(automarketProps),
      }; 
    } else {
      return null;
    }
  }

  _processMessageArgs(props) {
    const cmd = props.args.join(' ');
    const issued = new Date();

    const inMatch = cmd.match(inRegex);
    const everyMatch = cmd.match(everyRegex);
    
    const match = everyMatch || inMatch;

    if (!(everyMatch || inMatch)) {
      return null;
    } 

    const remind = everyMatch ? everyRemind(everyMatch[0]) :
      inMatch ? inDurationDatetime(inMatch[0]) :
      null;
    
    let msg = cmd.replace(everyMatch, "").trim();
    msg = msg.replace(inMatch, "").trim();
    if (msg[msg.length - 1] == ",") {
      msg = msg.substr(0, msg.length - 1);
      msg.trim();
    }

    if (!remind) {
      return null;
    }
    console.log(msg); 
    console.log(remind);  

    return {
      channel: props.channel,
      owner: props.owner,
      ownerid: props.ownerid,
      type: props.type,
      args: msg,
      issued: issued,
      scheduled: remind,
    };
  }

  _processAutoMarketArgs(props) { 
    
    const issued = new Date();
    const scheduled = `30 */${props.interval} * * * *`;
    return {
      channel: props.channel,
      owner: props.owner,
      ownerid: props.ownerid,
      type: props.type,
      args: props.args,
      itemID: props.itemID,
      filters: props.filters,
      issued: issued,
      scheduled: scheduled,
      name: props.name,
    };  
  }
}

// this denotes a delay in the reminder system
// e.g. *in* 5 hours.
function inDurationDatetime(inArgs) {
  const remindDate = new Date();
  // time regex object
  const duration = getDurationObj(durationRegexObj, inArgs);
  console.log(duration); 
  const hasDur = !Object.values(duration).every(o => o === null);
  if (!hasDur) {
    return null;
  } 

  remindDate.setSeconds(remindDate.getSeconds() + duration.second);
  remindDate.setMinutes(remindDate.getMinutes() + duration.minute);
  remindDate.setHours(remindDate.getHours() + duration.hour);
  remindDate.setDate(remindDate.getDate() + duration.day);
  remindDate.setDate(remindDate.getDate() + duration.week * 7);
  return remindDate;
}

function everyRemind(eArgs) {
  console.log(eArgs);

  const duration = getDurationObj(durationRegexObj, eArgs);
  console.log(duration);
  const every = duration.hour ? duration.hour :
    duration.minute ? duration.minute :
    duration.second ? duration.second :
    null;
  console.log(every); 
  
  return duration.hour ? `0 */${every} * * *` :
    duration.minute ? `*/${every} * * * *` :
    duration.second ? `*/${every} * * * * *` :
    null;
}

function getDurationObj(regexObj, args) {
  console.log(args); 
    // returns object of the duration result of each time unit.
  // if not found, that time unit will be 0 instead.
  return Object.keys(regexObj)
    .reduce((result, value) => {
      const curExp = new RegExp(inDigitRegex + regexObj[value]);
      const match = args.match(curExp);
      result[value] = match
        ? parseInt(match[0])
        : null;
      return result;
    }, {});
}

// this denotes a specific datetime for the reminder
// e.g. *at* :3ndex: 2, input: 'in 1 hr' ]
//
function atSpecificDatetime(atArgs) {

}

module.exports.TaskFactory = TaskFactory;
exports.CMD = CMD;
exports.TYPE = TYPE;
module.exports.MSG = MSG;
module.exports.AUTOMARKET = AUTOMARKET;
module.exports.INTERVAL = INTERVAL;
module.exports.REMOVE = REMOVE;
