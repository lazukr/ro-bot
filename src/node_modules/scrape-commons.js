// all scraping stuff
const logger = require('logger.js')("Scraping module");
const rp = require('request-promise').defaults({jar: true});
const cheerio = require('cheerio');
const dt = require('data-tables');
const config = require('../config.json');
const tf = require('task-factory');
const LINK = 'https://www.novaragnarok.com';
const sessionConfig = require('../../session.json');
const fs = require('fs');
const hooman = require('hooman');
const got = require('got');

const DADJOKE_URI = 'https://icanhazdadjoke.com/';


async function login(session = null) {

  
  const options = {
    searchParams: {
      'module': 'account',
      'action': 'login',
    },
    form: {
      username: config.novaUsername,
      password: config.novaPassword,
      server: 'NovaRO',
    },
    headers: {
      'Cookie': `fluxSessionData=${session ? session : tf.AutoMarketTask.session}`,
    },
  };

  try {
    const response = await got.post(LINK, options);
    const $ = cheerio.load(response.body);
    try {
      const loginBtn = $('input[type="submit"]').get(1).attribs.value;
      if (loginBtn === 'Log In') {
        return 0;
      }
    } catch {
      if (!session) {
        return 1;
      }
      sessionConfig.session = session;
      fs.writeFileSync('session.json', JSON.stringify(sessionConfig));
      tf.AutoMarketTask.session = session;
      tf.AutoMarketTask.loggedIn = true;
      tf.AutoMarketTask.messageSent = false;
      return 1;
    }

  } catch (error) {
    logger.error(`An error occurred with Nova login: ${error}`);
    return 0;
  }
  


  //console.log(tf.AutoMarketTask.session);


  /*
  const options = {
    method: 'POST',
    uri: LINK,
    qs: {
      module: 'account',
      action: 'login',
    },
    form: {
      username: config.novaUsername,
      password: config.novaPassword,
      server: 'NovaRO',
    },
    headers: {
      Cookie: `fluxSessionData=${session ? session : tf.AutoMarketTask.session}`,
    },
    followAllRedirects: true,
    transform: (body) => {
      return cheerio.load(body);
    },
  }
  return rp(options)
    .then($ => {
      try {
        const loginBtn = $('input[type="submit"]').get(1).attribs.value;
        //console.log(loginBtn);
        if (loginBtn === 'Log In') {
          return 0;
        }
      } catch {

        if (!session) {
          return 1;
        }

        sessionConfig.session = session;
        fs.writeFileSync('session.json', JSON.stringify(sessionConfig));
        tf.AutoMarketTask.session = session;
        tf.AutoMarketTask.loggedIn = true;
        tf.AutoMarketTask.messageSent = false;
        return 1;
      }
    })
    .catch(err => {
      console.log(`An error occurred with Nova login: ${err}`);
      return 0;
    });
    */
}

async function getPage(url, qs = {}) {

  const options = {
    searchParams: qs,
    headers: {
      Cookie: `fluxSessionData=${tf.AutoMarketTask.session}`,
    },
  }

  try {
    const response = await hooman.get(url, options);
    return cheerio.load(response.body);
  } catch (error) {
    logger.error(`An error has occurred on request. ${error}`);
  }


  /*
  const options = {
    method: 'GET',
    uri:    url,
    qs: qs,
    resolveWithFullResponse: true,
    headers: {
      Cookie: `fluxSessionData=${tf.AutoMarketTask.session}`,
    },
    transform: (body) => {
      return cheerio.load(body);
    },
  };

  
  return rp(options)
    .then($ => {
      return $;
    })
    .catch(err => {
      logger.error(`An error has occurred on request. ${err}`);
    });
  */
}

async function getDadJoke() {
  const options = {
    method: 'GET',
    uri: DADJOKE_URI,
    headers: {
      'Accept': 'application/json',
      'User-Agent': 'request (https://github.com/lazukr/ro-discord-bot)',
    },
    transform: (body) => {
      return JSON.parse(body);
    }
  };

  return rp(options)
    .then(res => {
      return res;
    })
    .catch(err => {
      logger.error(`An error has occurred on ${DADJOKE_URI}: ${err}`);
    });
}

exports.getPage = getPage;
exports.login = login;
exports.getDadJoke = getDadJoke;
