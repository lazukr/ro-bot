const NOVA_VEND = "nova_vend";
const BY_TEXT = "text";
const MARKET_TABLE = "market-table";
const TABLE = "table";
const DESCRIPTION = "description";

class DataTable {
  constructor(header, contents) {
    this.header = header;
    this.contents = contents;
  }

  get tableLength() {
    return this.contents.length;
  }

  static rowify($, table, type = TABLE) {
    const data = this._rowify($, table, type);
    return new DataTable(data.header, data.contents); 
  }

  static _getItemName($, id) {
    return $(id).find('div.item-name').text().trim();
  }

  static _rowify($, table, type) {
    const rows = $(table).find('tr');
    const header = {};
    $(rows).find('th').each((i, elem) => {
      const text = $(elem).text().trim();
        header[text] = text;
    });
    const keys = Object.keys(header);
    const contents = [];
    const content = $(rows).find('td').toArray();
    content.reduce((re, va, i, ar) => {
      if (i % keys.length === 0) {
        const curArray = ar.slice(i, i + keys.length);
        const dict = curArray.reduce((re, va, i) => {
          if (header[keys[i]] == "Item" &&
              type == MARKET_TABLE) {
            const tooltip = $(va).find('img')
              .data('tooltipContent');
            const name = this._getItemName($, tooltip);
            const itemID = tooltip.match(/\d+/g)[0];
            re[header[keys[i]]] = `${itemID} - ${name}`;
          } else if (type == DESCRIPTION) {
            re[header[keys[i]]] = $(va).text().trim();

          } else {
            re[header[keys[i]]] = $(va).text().trim()
              .split("\n")[0];
          }
          return re;
        }, {});
        contents.push(dict);
      }
    }, {});
    return {
      header: header,
      contents: contents,
    };
  }

  objectify() {
    return {
      header: this.header,
      contents: this.contents,
    };
  }

  checkColExists(col) {
    return this.header[col] ? true : false;
  }

}; 

class MarketTable extends DataTable {
  constructor(header, contents) {
    super(header, contents);
  }
  
  static rowify($, table, by = "html") {
    const data = super._rowify($, table, by);
    return new MarketTable(data.header, data.contents);
  } 

  strToIntCols(col) {
    if (!super.checkColExists(col)) {
      return;
    }
    this.contents.forEach(tr => {
      tr[col] = parseInt(tr[col].replace(/,|\+/g, ''));
    });  
  }

  intToStrCols(col) {
    if (!super.checkColExists(col)) {
      return;
    }
    this.contents.forEach(tr => {
      tr[col] = tr[col].toLocaleString();
    });
  }
  
  sort(col) {
    this.contents.sort((a, b) => {
      return a[col] - b[col];
    });  
  }

  abbreviate(header, abbreviators) {
    Object.keys(abbreviators).forEach(th => {
      if (this.header[header[th]]) {
        this.header[header[th]] = abbreviators[th];  
      }
    }); 
  }

  locToNavi(header, loc_navi) {
    this.contents.forEach(tr => {
      const locArray = tr[header.LOCATION].split(',');
      tr[header.LOCATION] = locArray[0] == NOVA_VEND ?
        `${loc_navi.NOVA} ${locArray[1]} ${locArray[2]}` :
        `${loc_navi.OTHER} ${locArray[0]} ${locArray[1]}/${locArray[2]}`;
    });
  }
}

exports.DataTable = DataTable;
exports.MarketTable = MarketTable;
exports.MARKET_TABLE = MARKET_TABLE;
exports.TABLE = TABLE;
exports.DESCRIPTION = DESCRIPTION;
