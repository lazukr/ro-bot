const NOVA_VEND = "nova_vend";
const BY_TEXT = "text";

class DataTable {
  constructor(header, contents) {
    this.header = header;
    this.contents = contents;
  }

  get tableLength() {
    return this.contents.length;
  }

  static rowify($, table, by = "html", header = "tr") {
    const data = this._rowify($, table, by, header);
    return new DataTable(data.header, data.contents); 
  }

  static _rowify($, table, by, th) {
    const rows = $(table).find('tr');
    const header = {};
    $(rows).find('th').each((i, elem) => {
      const text = $(elem).text().trim();
        header[text] = text;
    });
    const keys = Object.keys(header);
    const contents = [];
    const content = $(rows).find('td').toArray();
    content.reduce((re, va, i, ar) => {
      if (i % keys.length === 0) {
        const curArray = ar.slice(i, i + keys.length);
        const dict = curArray.reduce((re, va, i) => {
          re[header[keys[i]]] = by == BY_TEXT ?
            $(va)[by]().trim().split("\n")[0] :
            $(va)[by]().trim();
          return re;
        }, {});
        contents.push(dict);
      }
    }, {});
    return {
      header: header,
      contents: contents,
    };
  }

  objectify() {
    return {
      header: this.header,
      contents: this.contents,
    };
  }

  checkColExists(col) {
    return this.header[col] ? true : false;
  }

}; 

class MarketTable extends DataTable {
  constructor(header, contents) {
    super(header, contents);
  }
  
  static rowify($, table, by = "html") {
    const data = super._rowify($, table, by);
    return new MarketTable(data.header, data.contents);
  } 

  strToIntCols(col) {
    if (!super.checkColExists(col)) {
      return;
    }
    this.contents.forEach(tr => {
      tr[col] = parseInt(tr[col].replace(/,|\+/g, ''));
    });  
  }

  intToStrCols(col) {
    if (!super.checkColExists(col)) {
      return;
    }
    this.contents.forEach(tr => {
      tr[col] = tr[col].toLocaleString();
    });
  }
  
  sort(col) {
    this.contents.sort((a, b) => {
      return a[col] - b[col];
    });  
  }

  abbreviate(header, abbreviators) {
    Object.keys(abbreviators).forEach(th => {
      if (this.header[header[th]]) {
        this.header[header[th]] = abbreviators[th];  
      }
    }); 
  }

  locToNavi(header, loc_navi) {
    this.contents.forEach(tr => {
      const locArray = tr[header.LOCATION].split(',');
      tr[header.LOCATION] = locArray[0] == NOVA_VEND ?
        `${loc_navi.NOVA} ${locArray[1]} ${locArray[2]}` :
        `${loc_navi.OTHER} ${locArray[0]} ${locArray[1]}/${locArray[2]}`;
    });
  }
}

exports.DataTable = DataTable;
exports.MarketTable = MarketTable;
exports.BY_TEXT = BY_TEXT;
