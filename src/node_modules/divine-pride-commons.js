const logger = require('logger.js')("Divine Pride API Module");
const rp = require('request-promise');
const cheerio = require('cheerio');
const pp = require('pretty-print');
const sc = require('scrape-commons');
const dt = require('data-tables');

const dpLink = 'https://divine-pride.net';
const dpItemLink = `${dpLink}/database/item/`;
const dpMobLink = `${dpLink}/database/monster/`;
const dpSearchLink = `${dpLink}/database/search`;
const dpImage = 'https://static.divine-pride.net/images/';


const ERRNUM = Object.freeze({
  NAS: 1,
});

const SEARCH = Object.freeze({
  MOB: 0,
  ITEM: 1,
});

const ITEMINFO = Object.freeze({
  ID: 0,
  SELL_PRICE: 1,
  WEIGHT: 2,
  TYPE: 3,
  SUBTYPE: 4,
  LOCATION: 5,
});

const MOB_TABLE = Object.freeze({
  STATS: 0,
  ELEMENTS: 1,
});

function getData(message, args, type) {
  if (args.length === 0) {
    invalidInput(message, ERRNUM.NAS);
    return;
  }

  if (isNaN(args[0])) {
    getSearch(message, args, type);
    return;
  }

  const id = args.shift();
  
  if (type === SEARCH.ITEM) {
    getItem(message, id);
    return;
  }

  getMob(message, id);
}

function invalidInput(message, errnum) {
  switch(errnum) {
    case ERRNUM.NAS:
      message.channel.send(`Please specify an argument.`);
      return;
    default:
      message.channel.send(`This is a new species of errors`);
      return;
  }
}

function getItemInfo($) {
  const name = $('legend').first().text().trim();
  const description = $('table').first().find("tr td").eq(1)
    .html().trim()
    .replace(/<br>/gi, "\n")
    .replace(/<([^>]+)>/gi, "");
  const info = [];
  $('table').eq(1).find("tr td").each((i, elem) => {
    element = $(elem).text().trim();
    info.push(element);
  });
  const tables = {};

  const dropsTable = $('#drops').find('table');
  if (dropsTable.length) {
    tables.drops = dt.DataTable.rowify($, dropsTable);
  }
  //const sets = $('#sets');

  return {
    id: info[ITEMINFO.ID],
    name: name,
    description: description,
    tables: tables,
  }
}

function itemPrint(item) {
  return `${item.id} - ${item.name} \n\n${item.description}`; 
}

function mobPrint(mob) {
  
}



async function getItem(args) {
  const page = await sc.getPage(`${dpItemLink}${args}/`);
  return getItemInfo(page);
}

function getMobInfo($) {
  const name = $('legend').first().text().trim().split("\n")[0];
  const tables = {};

  const statsTable = $('table').eq(MOB_TABLE.STATS);
  const elemTable = $('table').eq(MOB_TABLE.ELEMENTS);
  const dropsTable = $('#drops').find('table').first();
  const mvpTable = $('#mvpdrops').find('table').first();
  tables.stats = dt.DataTable.rowify($, statsTable, dt.BY_TEXT);
  tables.elements = dt.DataTable.rowify($, elemTable, dt.BY_TEXT);
  tables.drops = dt.DataTable.rowify($, dropsTable, dt.BY_TEXT);
  tables.name = name;
  
  if (mvpTable) {
    tables.mvpDrops = dt.DataTable.rowify($, mvpTable, dt.DIVINE);
  }


  return tables;
}

async function getSearch(message, args, type) {
  
  const name = args.shift(); 
  const qs = {
    "q": name,
  }

  const $ = await sc.getPage(dpSearchLink, qs);
  const search = getSearchTable($, type);

  if (search === null) {
    message.channel.send(`No data found for search: ${name}`);
    return;
  }

  if (search.contents.length === 1) {
    const id = search.contents[0].Id;
    getMob(message, id);
    return;
  }

  const page = parseInt(args[0]) || 1;
  const table = {
    header: {
      Id: "Id",
      Name: "Name",
    },
    contents: [],
  };
  
  table.contents = search.contents.map(content => {
    return {
      Id: content.Id,
      Name: content.Name,
    };
  });
  
  const prettyTable = new pp.PrettyTableFactory({
    name: name,
    table: table
  });
  message.channel.send(prettyTable.getPage(page));
}

function getTable($, type) {
  const div = type === SEARCH.MOB ?
    $('#monster') :
    $('#items');

  const table = $(div).find('table').get(0);
  
  if (!table) {
    return null;
  }
  return table;
}


function getSearchTable($, type) {
  const table = getTable($, type);

  if (!table) {
    return null;
  }

  const search = dt.DataTable.rowify($, table, dt.DIVINE);
  return search;
}

async function getMob(message, args) {
  const ID = args;
  const page = await sc.getPage(`${dpMobLink}${ID}/`);
  const {name, stats, elements, drops, mvpDrops }  =  getMobInfo(page);

  const statsInfo = stats.contents[0];
  const elemInfo = elements ? elements.contents[0] : {};
  const dropsInfo = drops ? drops.contents : [];  
  const mvpInfo = mvpDrops ? mvpDrops.contents : [];
  
  const pStats = {
    header: {
      Race: "Race",
      Scale: "Scale",
      Element: "Element",
      Health: "Health",
      Range: "Range",
      Hit: "Hit",
      Flee: "Flee",
    },
    contents: [{
      Race: statsInfo.Race,
      Scale: statsInfo.Scale,
      Element: statsInfo.Element,
      Health: statsInfo.Health,
      Range: statsInfo.Range,
      Hit: statsInfo.Hit,
      Flee: statsInfo.Flee,
    }],
  };

  const sStats = {
    header: {
      Attack: "Atk",
      Matk: "Matk",
      Speed: "Speed",
      Aspd: "Aspd",
      Def: "Def",
      MDef: "MDef",
    },
    contents: [{
      Attack: statsInfo.Attack,
      Matk: statsInfo["Magic attack"],
      Speed: statsInfo["Speed (cells/sec)"],
      Aspd: statsInfo["Aspd (attacks/sec)"],
      Def: statsInfo.Def,
      MDef: statsInfo.MDef,
    }],
  };

  const fElems = {
    header: {
      Neutral: "Neutral",
      Water: "Water",
      Earth: "Earth",
      Fire: "Fire",
      Wind: "Wind",
    },
    contents: [{
      Neutral: elemInfo.Neutral,
      Water: elemInfo.Water,
      Earth: elemInfo.Earth,
      Fire: elemInfo.Fire,
      Wind: elemInfo.Wind,
    }],
  };

  const sElems = {
    header: {
      Poison: "Poison",
      Holy: "Holy",
      Dark: "Dark",
      Ghost: "Ghost",
      Undead: "Undead",
    },
    contents: [{
      Poison: elemInfo.Poison,
      Holy: elemInfo.Holy,
      Dark: elemInfo.Dark,
      Ghost: elemInfo.Ghost,
      Undead: elemInfo.Undead,
    }],
  };

  const pStatsTable = new pp.PrettyTableFactory({
    table: new dt.DataTable(pStats.header, pStats.contents),
  });

  const sStatsTable = new pp.PrettyTableFactory({
    table: new dt.DataTable(sStats.header, sStats.contents), 
  });

  const fElemTable = new pp.PrettyTableFactory({
    table: fElems,
  });

  const sElemTable = new pp.PrettyTableFactory({
    table: sElems, 
  });
  
  const embededMessage = {
    author: {
      name: `${statsInfo.Id} - ${name}`,
      icon_url: `${dpImage}mobs/png/${statsInfo.Id}.png`, 
      url: `${dpMobLink}${statsInfo.Id}`,
    },
    description: `**Level ${statsInfo.Level}**\n` + pStatsTable.getPage(1, {}, true) +
      sStatsTable.getPage(1, {}, true),
  }; 

  if (Object.keys(elemInfo).length !== 0) {
    embededMessage.description += "**Elements**\n" + 
      fElemTable.getPage(1, {}, true) +
      sElemTable.getPage(1, {}, true);
  }

  const fields = [];
  
  if (dropsInfo.length) {
    fields.push({
      name: "Drops",
      value: "**" + "- ".repeat(20) + "**",
    });

   fields.push(...dropsInfo.map(drop => {
      return {
        name: drop["Drop chance"],
        value: `${drop.Id} - ${drop.Name}`,
        inline: true,
      }; 
    }));
  }

  if (mvpInfo.length) {
    fields.push({
      name: "MVP Drops",
      value: "**" + "- ".repeat(20) + "**",
    });


    fields.push(...mvpInfo.map(drop => {
      return {
        name: drop["Drop Chance"],
        value: `${drop.Id} - ${drop.Name}`,
        inline: true,
      };
    }));
  }

  embededMessage.fields = fields;
  
  console.log(embededMessage);
  
  message.channel.send({embed: embededMessage}); 
}

exports.SEARCH = SEARCH;
exports.getItem = getItem;
exports.getMob = getMob;
exports.itemPrint = itemPrint;
exports.getData = getData;
