const logger = require('logger.js')("Pretty Print Module: ");
const HEADERS = require('nova-market-commons').HEADERS;
const dt = require('data-tables');
const HIGHLIGHT = 'JSON';
const TBL_LIM = 1950;
const ENTRY_LIM = [50, 25, 20, 15, 10];

class PrettyTableFactory {
  constructor(table) {
    if (table.table instanceof dt.MarketTable) {
      logger.debug("market-table");
      return new PrettyMarketTable(table.table, table.name, table.id);
    }
    logger.debug("data-table");
    return new PrettyTable(table.table, table.name);
  }
};

class PrettyTable {
  constructor(table, name) {

    this.header = table.header;
    if (this.header.hasOwnProperty('')) {
      delete this.header[''];
    }
    this.contents = table.contents;
    this.name = name; 
  } 

  get headerKeys() {
    return Object.keys(this.header);
  }

  _makeMaxLengthCols(contents) {
    return this.headerKeys.reduce((re, va) => {
      re[va] = Math.max(this.header[va].length,
        ...(contents.map(tr => {
        return tr[va].length;
      })));
      return re;
    }, {});
  }

  _stringify(separators, header, contents) {
    let table = [header];
    table.push(separators);
    table.push.apply(table, contents);
    
    table = table.map(tr => {
      return Object.values(tr).join(' | ');
    }); 
    
    return {
      header: table.shift(),
      separators: table.shift(),
      contents: table,
    };
  }

  _makeSeparators(maxlength) {
    return this.headerKeys.reduce((re, va) => {
      re[va] = '-'.repeat(maxlength[va]);
      return re;
    }, {});
  }

  _pad(maxlength, contents) {
    let table = [this.header];
    table.push.apply(table, contents);
    table = table.map(tr => {
      return this.headerKeys.reduce((re, va) => {
        re[va] = tr[va].padEnd(maxlength[va]);
        return re;
      }, {});
    });
    
    return {
      header: table.shift(),
      contents: table,
    } 
  }

  _paginate(header, contents) {
    const rowLength = header.length + 2;
    const tableLength = contents.length; 
    
    let i = 0;
    while ((ENTRY_LIM[i] + 1) * rowLength > TBL_LIM) {
      i++;
    }    
    
    return { 
      charPerMsg: ENTRY_LIM[i] * rowLength,
      entryPerPage: ENTRY_LIM[i],
      pages: Math.floor(tableLength / ENTRY_LIM[i]) + 1,
    };
  }

  _buildPage(components) {
    return `\`\`\`${HIGHLIGHT}\n`
      + `${components.name}\n\n`
      + `${components.header}\n`
      + `${components.separators}\n`
      + `${components.table}\n\n`
      + `Entries ${components.begEntry} to ${components.endEntry} of ${components.curTotalEntries}\n`
      + `\`\`\``;
  }
  getPage(page, filters = {}) { 
    console.log(this.contents);
    const maxLength = this._makeMaxLengthCols(this.contents);
    const separators = this._makeSeparators(maxLength); 
    const pad = this._pad(maxLength, this.contents);
    const stringify = this._stringify(separators, pad.header, pad.contents);
    const paginate = this._paginate(stringify.header, stringify.contents);
    const curTotalEntries = stringify.contents.length; 
    const pages = paginate.pages; 
    const header = stringify.header;
    const begEntry = 1 + paginate.entryPerPage * (page - 1);
    const endEntry = paginate.entryPerPage * page > curTotalEntries ? curTotalEntries : paginate.entryPerPage * page;
    const contents = stringify.contents.slice(begEntry - 1, endEntry).join("\n");
 
    const components = {
      name: this.name,
      header: header,
      separators: stringify.separators,
      table: contents,
      curTotalEntries: curTotalEntries,
      begEntry: begEntry > curTotalEntries ? curTotalEntries : begEntry,
      endEntry: endEntry > curTotalEntries ? curTotalEntries : endEntry,
    };
    const msg = this._buildPage(components); 
    logger.info(msg);
    return msg;
  }
}

class PrettyMarketTable extends PrettyTable {
  constructor(table, name, id) {
    super(table, name);
    this.id = id;
  }

  _buildPage(components) {
    return `\`\`\`${HIGHLIGHT}\n`
      + `${components.id} - ${components.name}\n\n`
      + `${components.header}\n`
      + `${components.separators}\n`
      + `${components.table}\n\n`
      + `Entries ${components.begEntry} to ${components.endEntry} of ${components.curTotalEntries} (Total: ${components.totalEntries})\n`
      + `\`\`\``;
  }

  _processRefine(contents, refine) {

    if (!refine || refine.length === 0) {
      return contents;
    }

    const rfn = refine.split("+");
    
    if (rfn[0] == "<") {
      return contents.filter(tr => {
        return parseInt(tr[HEADERS.REFINE]) <= parseInt(rfn[1]);
      });
    }
    return contents.filter(tr => {
      return parseInt(tr[HEADERS.REFINE]) >= parseInt(rfn[1]);
    }); 
  }

  _processAddProps(contents, addprops) {
    if (!addprops || addprops.length === 0) {
      return contents; 
    }
/*
    if (addprops.length === 1) {
    // filters out non matching contents
      console.log(`filter out results that do not have positive matching contents`);
  
      const filtered = contents.filter(tr => {
        const trprops = tr[HEADERS.ADDPROPS].toLowerCase();
        const filtered = addprops.every(props => {
          console.log(`props: ${props}`);
          return props.every(prop => {
            //console.log(prop); 
            // skip negative cases
            if (prop.startsWith('!')) {
              return !trprops.includes(prop.substring(1));
            }
            return trprops.includes(prop);
          });
        });
        return filtered; 
      });
      console.log(`Filter 1:\n${JSON.stringify(filtered)}`);
      return filtered;
    }
    //console.log(`filtering for exact matches`);
    // filters out matches that don't have exact to specified parameters
  */  
    
    const secondfiltered = contents.filter(tr => {
      const trprops = tr[HEADERS.ADDPROPS].toLowerCase().split(/[,.]/)
        .map(x => x.trim()).filter(x => x !== '');
      
      //console.log(`LOOKING AT: ${trprops}`);  
      let count = 0;
      const matches = [];


      for (let i = 0; i < addprops.length; i++) {
        for (let j = 0; j < trprops.length; j++) {
          //console.log(addprops[i]);
               
          // negative cases are handle with a negate in front
          // to make sure it does NOT include the property
          const exactMatch = addprops[i].every(ap => {
            if (ap.startsWith('!')) {
              return !trprops[j].includes(ap.substring(1));
            }
            return trprops[j].includes(ap);
          });
          
          if (exactMatch) {
            //console.log(`cur ap: ${addprops[i]}`); 
            //console.log(matches);
            
            const sameSearch = matches.filter(m => {
              return m.ap === addprops[i];
            });
            
            //console.log(`sameSearch: ${sameSearch}`);      
          
            if (!sameSearch.length) {
              matches.push({
                ap: addprops[i],
                tr: trprops[j],
              });
              count++;
              break;
            };
          }
        }
      }
      return count === addprops.length ? true : false;
    }); 
    
    console.log(`Filter 2:\n${JSON.stringify(secondfiltered)}`);

    return secondfiltered;
  }

  _processPrice(contents, price) {

    if (!price || price.length === 0) {
      return contents;
    }
    return contents.filter(tr => {
      const trprice = tr[HEADERS.PRICE].replace(/,/g, '');
      return parseInt(trprice) <= parseInt(price);
    });
  }


  _doFilters(filters) {
    let table = this._processRefine(this.contents, filters[HEADERS.REFINE]);
    table = this._processPrice(table, filters[HEADERS.PRICE]);
    table = this._processAddProps(table, filters[HEADERS.ADDPROPS]);
    return table;
  }

  getPage(page, filters) {
    
    const totalEntries = this.contents.length;
    const table = this._doFilters(filters);
    
    if (!table.length) {
      return false;
    }
    
    const maxLength = this._makeMaxLengthCols(table);
    const separators = this._makeSeparators(maxLength); 
    const pad = this._pad(maxLength, table);
    const stringify = this._stringify(separators, pad.header, pad.contents);
    const paginate = this._paginate(stringify.header, stringify.contents);
    const curTotalEntries = stringify.contents.length; 
    const pages = paginate.pages; 
    const header = stringify.header;
    const begEntry = 1 + paginate.entryPerPage * (page - 1);
    const endEntry = paginate.entryPerPage * page > curTotalEntries ? curTotalEntries : paginate.entryPerPage * page;
    const contents = stringify.contents.slice(begEntry - 1, endEntry).join("\n");
    const components = {
      id: this.id,
      name: this.name,
      header: header,
      separators: stringify.separators,
      table: contents,
      curTotalEntries: curTotalEntries,
      begEntry: begEntry,
      endEntry: endEntry,
      totalEntries: totalEntries,
    };
    const msg = this._buildPage(components); 
    logger.info(msg);
    return msg;
  }
};

exports.PrettyTableFactory = PrettyTableFactory;
