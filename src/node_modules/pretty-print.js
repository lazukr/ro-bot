const logger = require('logger.js')("Pretty Print Module: ");
const HEADERS = require('nova-market-commons').HEADERS;
const ERRORS = require('nova-market-commons').ERROR;
const dt = require('data-tables');
const HIGHLIGHT = 'JSON';
const TBL_LIM = 1950;
const ENTRY_LIM = [50, 25, 20, 15, 10, 1];

class PrettyTableFactory {
  constructor(table) {
    if (table.table instanceof dt.MarketTable) {
      logger.debug("market-table");
      return new PrettyMarketTable(table.table, table.name, table.id);
    }
    logger.debug("data-table");
    return new PrettyTable(table.table, table.name);
  }
};

class PrettyTable {
  constructor(table, name) {

    this.header = table.header;
    if (this.header.hasOwnProperty('')) {
      delete this.header[''];
    }
    this.contents = table.contents;
    this.name = name; 
  } 

  get headerKeys() {
    return Object.keys(this.header);
  }

  _makeMaxLengthCols(contents) {
    return this.headerKeys.reduce((re, va) => {
      re[va] = Math.max(this.header[va].length,
        ...(contents.map(tr => {
        return tr[va].length;
      })));
      return re;
    }, {});
  }

  _stringify(separators, header, contents) {
    let table = [header];
    table.push(separators);
    table.push.apply(table, contents);
    
    table = table.map(tr => {
      return Object.values(tr).join(' | ');
    }); 
    
    return {
      header: table.shift(),
      separators: table.shift(),
      contents: table,
    };
  }

  _makeSeparators(maxlength) {
    return this.headerKeys.reduce((re, va) => {
      re[va] = '-'.repeat(maxlength[va]);
      return re;
    }, {});
  }

  _pad(maxlength, contents) {
    let table = [this.header];
    table.push.apply(table, contents);
    table = table.map(tr => {
      return this.headerKeys.reduce((re, va) => {
        re[va] = tr[va].padEnd(maxlength[va]);
        return re;
      }, {});
    });
    
    return {
      header: table.shift(),
      contents: table,
    } 
  }

  _paginate(header, contents) {
    const rowLength = header.length + 3;
    const tableLength = contents.length; 

    let i = 0;
    while ((ENTRY_LIM[i] + 1) * rowLength > TBL_LIM) {
      i++;
    }    

    return { 
      charPerMsg: ENTRY_LIM[i] * rowLength,
      entryPerPage: ENTRY_LIM[i],
      pages: Math.floor(tableLength / ENTRY_LIM[i]) + 1,
    };
  }

  _buildPage(components, supEntries) {

    let page =  `\`\`\`${HIGHLIGHT}\n`
      + `${components.name ? components.name + '\n\n' : ""}`
      + `${components.header}\n`
      + `${components.separators}\n`
      + `${components.table}`;

    if (!supEntries) {
      page += `\n\n`
       + `Entries ${components.begEntry} to ${components.endEntry} of ${components.curTotalEntries}\n`;
    }
    page += `\`\`\``;

    return page;
  }
  getPage(page, filters = {}, supressEntries = false) { 
    const maxLength = this._makeMaxLengthCols(this.contents);
    const separators = this._makeSeparators(maxLength); 
    const pad = this._pad(maxLength, this.contents);
    const stringify = this._stringify(separators, pad.header, pad.contents);
    const paginate = this._paginate(stringify.header, stringify.contents);
    const curTotalEntries = stringify.contents.length; 
    const pages = paginate.pages; 
    const header = stringify.header;
    const begEntry = 1 + paginate.entryPerPage * (page - 1);
    const endEntry = paginate.entryPerPage * page > curTotalEntries ? curTotalEntries : paginate.entryPerPage * page;
    const contents = stringify.contents.slice(begEntry - 1, endEntry).join("\n");
 
    const components = {
      name: this.name,
      header: header,
      separators: stringify.separators,
      table: contents,
      curTotalEntries: curTotalEntries,
      begEntry: begEntry > curTotalEntries ? curTotalEntries : begEntry,
      endEntry: endEntry > curTotalEntries ? curTotalEntries : endEntry,
    };
    const msg = this._buildPage(components, supressEntries); 
    logger.info(msg);
    return msg;
  }
}

class PrettyMarketTable extends PrettyTable {
  constructor(table, name, id) {
    super(table, name);
    this.id = id;
  }

  _buildPage(components, supressEntries) {
    return `\`\`\`${HIGHLIGHT}\n`
      + `${components.id} - ${components.name}\n\n`
      + `${components.header}\n`
      + `${components.separators}\n`
      + `${components.table}\n\n`
      + `Entries ${components.begEntry} to ${components.endEntry} of ${components.curTotalEntries} (Total: ${components.totalEntries})\n`
      + `\`\`\``;
  }

  _processRefine(contents, refine) {

    if (!refine || refine.length === 0) {
      return contents;
    }

    const rfn = refine.split("+");
    
    if (rfn[0] == "<") {
      return contents.filter(tr => {
        return parseInt(tr[HEADERS.REFINE]) <= parseInt(rfn[1]);
      });
    }
    return contents.filter(tr => {
      return parseInt(tr[HEADERS.REFINE]) >= parseInt(rfn[1]);
    }); 
  }

  _processAddProps(contents, addprops) {
   
    addprops = addprops.map(i => {
      return i.map(j => {
        return j.split(' ');
      })[0];
    });
    //console.log(contents); 

		//console.log(addprops); 
   
    //console.log(this.name);
    const firstfiltered = this.name.toLowerCase().match(/^\scard$/) ?
      contents :
      contents.filter(tr => {
      const trprops = tr[HEADERS.ADDPROPS]
        .toLowerCase()
        .split(/(?<![Ll]v)\.|,/)
        .map(x => x.trim())
        .filter(x => x !== '');
      //console.log(trprops);
      return !trprops.includes(this.name.toLowerCase());
    });
     
    //console.log(firstfiltered);

    const secondfiltered = firstfiltered.filter(tr => {
      const trprops = tr[HEADERS.ADDPROPS].toLowerCase().split(/(?<![Ll]v)\.|,/)
        .map(x => x.trim()).filter(x => {
          return x !== '';
        }); 
      
      //console.log(`LOOKING AT: ${trprops}`);  
      let count = 0;
      const matches = [];


      for (let i = 0; i < addprops.length; i++) {
        for (let j = 0; j < trprops.length; j++) {
          
          //console.log(matches); 
          // negative cases are handle with a negate in front
          // to make sure it does NOT include the property
          const exactMatch = addprops[i].every(ap => {
            if (ap.startsWith('!')) {
              return !trprops[j].includes(ap.substring(1));
            }
            return trprops[j].includes(ap);
          });
          
          if (exactMatch) {
            //console.log(`cur ap: ${addprops[i]}`); 
             
            //console.log(`j: ${j}`); 
            const sameSearch = matches.filter(m => {
              //console.log(`${m.ap}`);
              return m.tr === j;
            });
            
            //console.log(`sameSearch: ${sameSearch}`);      

            //console.log(sameSearch.length);
            if(sameSearch.length) {
              //console.log('searching for same thing on same entry');
              continue;
            }

            matches.push({
              ap: addprops[i],
              tr: j,
            });
            count++;
            break;
          }
        }
      }
      return count === addprops.length ? true : false;
    }); 
    
    console.log(`Filter 2:\n${JSON.stringify(secondfiltered)}`);

    return secondfiltered;
  }

  _processPrice(contents, price) {
    
    if (!price || price.length === 0) {
      return contents;
    }
    return contents.filter(tr => {
      const trprice = tr[HEADERS.PRICE].replace(/,/g, '');
      return parseInt(trprice) <= parseInt(price);
    });
  }


  _doFilters(filters) {
    let table = this._processRefine(this.contents, filters[HEADERS.REFINE]);
    table = this._processPrice(table, filters[HEADERS.PRICE]);
    if (this.headerKeys.includes(HEADERS.ADDPROPS)) {
      table = this._processAddProps(table, filters[HEADERS.ADDPROPS]);
    }
    return table;
  }

  getFilteredResults(filters) {
    return this._doFilters(filters);
  }


  hasResults(filters) {
    const filteredTable = this._doFilters(filters);
    return filteredTable.length ? true : false;
  }

  getPage(page, filters, supressedEntries = false) {
    const totalEntries = this.contents.length;
    const table = this._doFilters(filters);
    const maxLength = this._makeMaxLengthCols(table);
    const separators = this._makeSeparators(maxLength); 
    const pad = this._pad(maxLength, table);
    
    const stringify = this._stringify(separators, pad.header, pad.contents);
    const paginate = this._paginate(stringify.header, stringify.contents);
    
    if (table.length === 0) {
      stringify.contents.push(`\n --- No Matching Results --- `);
    }
    
    const curTotalEntries = stringify.contents.length; 
    const pages = paginate.pages; 
    const header = stringify.header;
    const begEntry = 1 + paginate.entryPerPage * (page - 1);
    const endEntry = paginate.entryPerPage * page > curTotalEntries ? curTotalEntries : paginate.entryPerPage * page;
    const contents = stringify.contents.slice(begEntry - 1, endEntry).join("\n");
    
    const components = {
      id: this.id,
      name: this.name,
      header: header,
      separators: stringify.separators,
      table: contents,
      curTotalEntries: curTotalEntries,
      begEntry: begEntry,
      endEntry: endEntry,
      totalEntries: totalEntries,
    };
    const msg = this._buildPage(components, supressedEntries); 
    //logger.info(msg);
    return msg;
  }
};

exports.PrettyTableFactory = PrettyTableFactory;
exports.HIGHLIGHT = HIGHLIGHT;
