const logger = require('logger.js')("Pretty Print Module: ");
const HEADERS = require('nova-market-commons').HEADERS;
const HIGHLIGHT = 'JSON';
const TBL_LIM = 1950;
const ENTRY_LIM = [50, 25, 20, 15, 10];

class PrettyTable {
  constructor(market) {
    this.id = market.id;
    this.name = market.name;
    this.header = market.table.header;
    this.contents = market.table.contents; 
  }

  get headerKeys() {
    return Object.keys(this.header);
  }

  _makeMaxLengthCols(contents) {
    return this.headerKeys.reduce((re, va) => {
      re[va] = Math.max(this.header[va].length,
        ...(contents.map(tr => {
        return tr[va].length;
      })));
      return re;
    }, {});
  }

  _stringify(separators, header, contents) {
    let table = [header];
    table.push(separators);
    table.push.apply(table, contents);
    
    table = table.map(tr => {
      return Object.values(tr).join(' | ');
    }); 
    
    return {
      header: table.shift(),
      separators: table.shift(),
      contents: table,
    };
  }

  _makeSeparators(maxlength) {
    return this.headerKeys.reduce((re, va) => {
      re[va] = '-'.repeat(maxlength[va]);
      return re;
    }, {});
  }

  _pad(maxlength, contents) {
    let table = [this.header];
    table.push.apply(table, contents);
    table = table.map(tr => {
      return this.headerKeys.reduce((re, va) => {
        re[va] = tr[va].padEnd(maxlength[va]);
        return re;
      }, {});
    });
    
    return {
      header: table.shift(),
      contents: table,
    } 
  }

  _paginate(header, contents) {
    const rowLength = header.length + 2;
    const tableLength = contents.length; 
    
    let i = 0;
    while ((ENTRY_LIM[i] + 1) * rowLength > TBL_LIM) {
      i++;
    }    
    
    return { 
      charPerMsg: ENTRY_LIM[i] * rowLength,
      entryPerPage: ENTRY_LIM[i],
      pages: Math.floor(tableLength / ENTRY_LIM[i]) + 1,
    };
  }

  _buildPage(components) {
    return `\`\`\`${HIGHLIGHT}\n`
      + `${components.id} - ${components.name}\n\n`
      + `${components.header}\n`
      + `${components.separators}\n`
      + `${components.table}\n\n`
      + `Entries ${components.begEntry} to ${components.endEntry} of ${components.curTotalEntries} (Total: ${components.totalEntries})\n`
      + `\`\`\``;
  }

  _processRefine(contents, refine) {

    if (!refine) {
      return contents;
    }

    const rfn = refine.split("+");
    
    console.log(rfn);
    if (rfn[0] == "<") {
      return contents.filter(tr => {
        return parseInt(tr[HEADERS.REFINE]) <= parseInt(rfn[1]);
      });
    }
    return contents.filter(tr => {
      return parseInt(tr[HEADERS.REFINE]) >= parseInt(rfn[1]);
    }); 
  }

  _processAddProps(contents, addprops) {
    if (!addprops) {
      return contents; 
    }
    return contents.filter(tr => {
      const trprops = tr[HEADERS.ADDPROPS].toLowerCase();
      return addprops.every(props => trprops.includes(props.toLowerCase()));
    });
  }

  getPage(page, filters) {
    
    const totalEntries = this.contents.length;
    let table = this._processRefine(this.contents, filters[HEADERS.REFINE]);
    table = this._processAddProps(table, filters[HEADERS.ADDPROPS]);
    const maxLength = this._makeMaxLengthCols(table);
    const separators = this._makeSeparators(maxLength); 
    const pad = this._pad(maxLength, table);
    const stringify = this._stringify(separators, pad.header, pad.contents);
    const paginate = this._paginate(stringify.header, stringify.contents);
    const curTotalEntries = stringify.contents.length; 
    const pages = paginate.pages; 
    const header = stringify.header;
    const begEntry = 1 + paginate.entryPerPage * (page - 1);
    const endEntry = paginate.entryPerPage * page > curTotalEntries ? curTotalEntries : paginate.entryPerPage * page;
    const contents = stringify.contents.slice(begEntry - 1, endEntry).join("\n");
    const components = {
      id: this.id,
      name: this.name,
      header: header,
      separators: stringify.separators,
      table: contents,
      curTotalEntries: curTotalEntries,
      begEntry: begEntry,
      endEntry: endEntry,
      totalEntries: totalEntries,
    };
    const msg = this._buildPage(components); 
    logger.info(msg);
    return msg;
  }

  print() {
    console.log(this.header);
    console.log(this.separators);
    this.contents.forEach(tr => {
      console.log(tr);
    });
  }
};

exports.PrettyTable = PrettyTable;
