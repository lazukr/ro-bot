const QTY = 'Qty';
const PRICE = 'Price';
const HIGHLIGHT = 'JSON';
const MSG_LIM = 2000;
const RSV_LIM = 50;

// joins every item in the row into one string
function stringifyTable(table) {
  return table.map(row => {
    return Object.values(row).join(' | ');
  }); 
}

// creates a separator to divide the header from
// the actual table content
function getTableSeparator(headerList, padValues) {
  return headerList.reduce((result, value) => {
    result[value] = '-'.repeat(padValues[value]);
    return result;
  }, {});
}

function prettyPrint(header, table, reserve = false) {
  const formatted = formatTable(header, table);
  const rowLength = formatted[0].length + 1;
  const rsvRowRatio = RSV_LIM / rowLength + 1; 
  // accomodate the reserve
  // probably won't be longer than a row
  const numRows = reserve ? formatted.length + rsvRowRatio : formatted.length;
  console.log(formatted);

  // numRows to accomodate the reserve
  // reserve will probably be never as long as a row
  if (rowLength * (numRows) < MSG_LIM) {
    return {
      firstMsg: reserve ? formatted : null,
      formatted: reserve ? [] : [formatted],
    }
  }

  const threshold = MSG_LIM / rowLength;
  const multiMsg = [];

  let firstMsg = null;
  if (reserve) {
    firstMsg = formatted.splice(0, threshold - 1);
  }
  
  while(formatted.length) {
    multiMsg.push(formatted.splice(0, threshold));
  }
  
  return {
    firstMsg: firstMsg,
    formatted: multiMsg, 
  }
}


// formats the table to be in a printable form
function formatTable(header, table) {
  const headerList = Object.keys(header);
  table.unshift(header);
  const tablePadValues = getDictOfMaxStrInCols(headerList, table);
  const tableSeparator = getTableSeparator(headerList, tablePadValues);
  
  // inserts the header / table separator 
  table.splice(1, 0, tableSeparator);
  const paddedTable = table.map(row => {
    return headerList.reduce((result, value) => {
      result[value] = row[value].padEnd(tablePadValues[value]);
      return result; 
    }, {});  
  });
  return stringifyTable(paddedTable);
}

// gets max string length in each column
// returns as dictionary
function getDictOfMaxStrInCols(headerList, table) {
  return headerList.reduce((result, value) => {
    result[value] = Math.max(...(table.map(col => {
      return col[value].length;
    })));
    return result; 
  }, {});
}

// converts integer columns back to strings
// inserts the commas (,) for thousands separating
function getStringIntsInCol(array, col) {
  return array.map(row => {
    row[col] = row[col].toLocaleString();
    return row;
  });
}

module.exports.print = prettyPrint;
module.exports.getStringIntsInCol = getStringIntsInCol;
module.exports.QTY = QTY;
module.exports.PRICE = PRICE;
module.exports.MSG_LIM = MSG_LIM;
module.exports.HIGHLIGHT= HIGHLIGHT;
